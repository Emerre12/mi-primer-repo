<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Tesseract 4D Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: sans-serif; }
    #info { position: absolute; top: 0; left: 0; padding: 10px; font-size: 14px; z-index: 1; }
  </style>
</head>
<body>
<div id="info">ðŸŽ® Arrastra para rotar, usa scroll para acercar/alejar â€” Visualizador 4D âžœ 3D</div>

<!-- Three.js y OrbitControls con 'defer' para evitar errores -->
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/OrbitControls.min.js" defer></script>

<!-- Tu cÃ³digo JavaScript -->
<script defer>
document.addEventListener('DOMContentLoaded', () => {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(4, 4, 6);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // --- VÃ©rtices del tesseracto en 4D ---
  const verts4D = [];
  for (let i = 0; i < 16; i++) {
    verts4D.push(new THREE.Vector4(
      (i & 1) ? 1 : -1,
      (i & 2) ? 1 : -1,
      (i & 4) ? 1 : -1,
      (i & 8) ? 1 : -1
    ));
  }

  // --- Conexiones (aristas) entre vÃ©rtices que difieren en 1 eje ---
  const edges = [];
  for (let i = 0; i < 16; i++) {
    for (let j = i + 1; j < 16; j++) {
      if ([1,2,4,8].includes(i ^ j)) edges.push([i, j]);
    }
  }

  // --- GeometrÃ­a de lÃ­neas 3D ---
  const posArray = new Float32Array(edges.length * 2 * 3);
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
  const material = new THREE.LineBasicMaterial({ color: 0x00ffff });
  const lines = new THREE.LineSegments(geometry, material);
  scene.add(lines);

  // --- ProyecciÃ³n 4D â†’ 3D ---
  function project4Dto3D(v) {
    const d = 4; // distancia de "cÃ¡mara" en w
    const factor = d / (d - v.w);
    return new THREE.Vector3(v.x * factor, v.y * factor, v.z * factor);
  }

  // --- RotaciÃ³n en dos planos hiperdimensionales ---
  function rotate4D(vector, axis1, axis2, angle) {
    const s = Math.sin(angle), c = Math.cos(angle);
    const A = vector[axis1], B = vector[axis2];
    vector[axis1] = A * c - B * s;
    vector[axis2] = A * s + B * c;
  }

  // --- AnimaciÃ³n principal ---
  function animate() {
    requestAnimationFrame(animate);

    // Rotar en planos XW y YZ
    verts4D.forEach(v => {
      rotate4D(v, 'x', 'w', 0.01);
      rotate4D(v, 'y', 'z', 0.008);
    });

    // Proyectar vÃ©rtices y actualizar posiciones
    let i = 0;
    for (const [a, b] of edges) {
      const v1 = project4Dto3D(verts4D[a]);
      const v2 = project4Dto3D(verts4D[b]);
      posArray[i++] = v1.x; posArray[i++] = v1.y; posArray[i++] = v1.z;
      posArray[i++] = v2.x; posArray[i++] = v2.y; posArray[i++] = v2.z;
    }

    geometry.attributes.position.needsUpdate = true;

    controls.update();
    renderer.render(scene, camera);
  }

  animate();

  // --- Adaptar a cambios de tamaÃ±o de ventana ---
  window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
});
</script>
</body>
</html>
