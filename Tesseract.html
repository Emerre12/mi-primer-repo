<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hypercube Viewer</title>
  <style>
    body { margin: 0; background: black; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/OrbitControls.min.js"></script>
<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
camera.position.set(3, 3, 6);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// --- Generar los vértices del hipercubo en 4D ---
const verts4D = [];
for (let i = 0; i < 16; i++) {
  verts4D.push(new THREE.Vector4(
    (i & 1) ? 1 : -1,
    (i & 2) ? 1 : -1,
    (i & 4) ? 1 : -1,
    (i & 8) ? 1 : -1
  ));
}

// --- Aristas entre vértices conectados por 1 eje ---
const edges = [];
for (let i = 0; i < 16; i++) {
  for (let j = i + 1; j < 16; j++) {
    if ([1,2,4,8].includes(i ^ j)) edges.push([i, j]);
  }
}

// --- Crear línea con BufferGeometry ---
const pos = new Float32Array(edges.length * 2 * 3); // 2 vértices por arista × 3 coords
const geom = new THREE.BufferGeometry();
geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
const lines = new THREE.LineSegments(geom, new THREE.LineBasicMaterial({ color: 0x00ffff }));
scene.add(lines);

// --- Proyección de 4D a 3D ---
function project(v) {
  const d = 3.5;
  const f = d / (d - v.w);
  return new THREE.Vector3(v.x * f, v.y * f, v.z * f);
}

// --- Rotaciones 4D básicas ---
function rotate(v, a1, a2, theta) {
  const c = Math.cos(theta), s = Math.sin(theta);
  const A = v[a1], B = v[a2];
  v[a1] = A * c - B * s;
  v[a2] = A * s + B * c;
}

// --- Animación ---
function animate() {
  requestAnimationFrame(animate);

  // Rotar en dos planos del hipercubo
  verts4D.forEach(v => {
    rotate(v, 'x', 'w', 0.01);
    rotate(v, 'y', 'z', 0.008);
  });

  // Actualizar geometría
  let idx = 0;
  for (const [i, j] of edges) {
    const p1 = project(verts4D[i]);
    const p2 = project(verts4D[j]);
    pos[idx++] = p1.x; pos[idx++] = p1.y; pos[idx++] = p1.z;
    pos[idx++] = p2.x; pos[idx++] = p2.y; pos[idx++] = p2.z;
  }

  geom.attributes.position.needsUpdate = true;

  controls.update();
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
